<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Winbows11 - Install</title>
    <link rel="stylesheet" href="./install.css">
</head>

<body>
    <div class="install winui">
        <div class="install-window">
            <div class="install-percent"></div>
            <div class="install-progress">
                <div class="install-progress-bar">
                    <div class="install-progress-bar-peg"></div>
                </div>
            </div>
            <div class="install-info"></div>
            <div class="install-details">
                <div class="install-detail-installeds"></div>
            </div>
        </div>
    </div>
    <script>
        const mainDisk = 'C';
        const debuggerMode = false;

        // File System Class
        !(() => {
            class IDBFS {
                constructor(dbName, mainDisk = 'C') {
                    this.dbName = dbName;
                    this.db = null;
                    this.mainDisk = mainDisk;
                    this.disks = [];
                    this.debuggerMode = debuggerMode;
                }

                async init() {
                    return new Promise((resolve, reject) => {
                        const request = indexedDB.open(this.dbName);
                        request.onupgradeneeded = (event) => {
                            const db = event.target.result;
                            const store = db.createObjectStore(this.mainDisk, { keyPath: 'path' });
                            store.createIndex('path', 'path', { unique: true });
                        };
                        request.onsuccess = async (event) => {
                            this.db = event.target.result;
                            var mainDiskExist = false;
                            Array.from(event.target.result.objectStoreNames).forEach(async name => {
                                if (name === this.mainDisk) {
                                    mainDiskExist = true;
                                }
                                this.disks.push(name);
                            });
                            if (mainDiskExist == false) {
                                await this.createDisk(mainDiskExist)
                            }
                            const db = event.target.result;
                            db.onversionchange = function () {
                                db.close();
                            };

                            resolve();
                        };
                        request.onerror = (event) => {
                            reject(event.target.error);
                        };
                    })
                }

                async createDisk(diskName, config) {
                    if (!this.db) {
                        await this.init();
                    }
                    if (!this.db.objectStoreNames.contains(diskName)) {
                        return new Promise((resolve) => {
                            const request = indexedDB.open(this.dbName, this.db.version + 1);
                            request.onupgradeneeded = (event) => {
                                this.console.log('Upgrading database to version', event.oldVersion, 'to', event.newVersion);
                                const db = event.target.result;
                                if (!db.objectStoreNames.contains(diskName)) {
                                    const store = db.createObjectStore(diskName, { keyPath: 'path' });
                                    store.createIndex('path', 'path', { unique: true });
                                }
                            };
                            request.onsuccess = (event) => {
                                this.db = event.target.result;
                                this.disks.push(diskName)
                                Array.from(event.target.result.objectStoreNames).forEach(async name => {

                                });
                                resolve(true);
                            };
                        });
                    }
                }

                computePath(path, currentPath) {
                    const currentPathDirs = currentPath.split('/').filter(dir => dir !== '');
                    const pathDirs = path.split('/').filter(dir => dir !== '');

                    const resultPath = [...currentPathDirs];

                    for (const dir of pathDirs) {
                        if (dir === '..') {
                            if (resultPath.length > 0) {
                                resultPath.pop();
                            }
                        } else if (dir !== '.') {
                            resultPath.push(dir);
                        }
                    }

                    const outputPath = resultPath.join('/');

                    return outputPath;
                }

                parseURL(url = '') {
                    url = url.replaceAll('\\', '/');
                    var disk = ((/([A-Z]{1})(\:\/)/gi).exec(url) || [])[1] || this.mainDisk;
                    var path = url.replace(`${disk}:/`, '');
                    return { disk, path };
                }

                debugger(method, message) {
                    if (this.debuggerMode == true) {
                        console.log('%c[IDBFS DEBUGGER]', 'color: #f670ff', `${method} - ${message}`);
                    }
                }

                // OK
                async list(url) {
                    const parsed = this.parseURL(url);
                    return new Promise((resolve, reject) => {
                        const transaction = this.db.transaction(parsed.disk, 'readonly');
                        const store = transaction.objectStore(parsed.disk);
                        const request = store.index('path').getAllKeys() // getAll(IDBKeyRange.only(path));
                        request.onsuccess = (event) => {
                            const files = event.target.result;
                            // console.log(files)
                            // const dirFiles = files.filter((file) => file.startsWith(`${path}/`));
                            this.debugger('list', `List the contents of disk successfully!`);
                            resolve(files);
                            // resolve(dirFiles.map((file) => file.path));
                        };
                        request.onerror = (event) => {
                            this.debugger('list', `Failed to list the contents of disk.`);
                            reject(event.target.error);
                        };
                    });
                }

                // OK
                async open(url) {
                    const parsed = this.parseURL(url);
                    return new Promise((resolve, reject) => {
                        const transaction = this.db.transaction(parsed.disk, 'readwrite');
                        const store = transaction.objectStore(parsed.disk);
                        const request = store.get(parsed.path);
                        request.onsuccess = (event) => {
                            const file = event.target.result;
                            if (file) {
                                this.debugger('open', `File "${url}" has been opened successfully!`);
                                resolve(file);
                            } else {
                                this.debugger('open', `Failed to open file "${url}".`);
                                reject(new Error(`File not found: ${url}`));
                            }
                        };
                        request.onerror = (event) => {
                            reject(event.target.error);
                        };
                    });
                }

                // OK
                async writeFile(url, content) {
                    const parsed = this.parseURL(url);
                    if (!await this.exists(url).exists) {
                        var splitted = parsed.path.split('/');
                        for (let i = 0; i < splitted.length; i++) {
                            var dir = `${parsed.disk}:/${splitted.slice(0, i + 1).join('/')}`;
                            if (!await this.exists(dir).exists) {
                                await this.mkdir(dir)
                            }
                        }
                    }
                    return new Promise((resolve, reject) => {
                        const transaction = this.db.transaction(parsed.disk, 'readwrite');
                        const store = transaction.objectStore(parsed.disk);
                        const request = store.put({ path: parsed.path, content, type: 'file' });
                        request.onsuccess = (event) => {
                            this.debugger('writeFile', `File "${url}" has been writen successfully!`);
                            resolve(content);
                        };
                        request.onerror = (event) => {
                            this.debugger('writeFile', `Failed to write file "${url}".`);
                            reject(event.target.error);
                        };
                    });
                }

                // OK
                async readFile(url) {
                    const parsed = this.parseURL(url);
                    return new Promise((resolve, reject) => {
                        const transaction = this.db.transaction(parsed.disk, 'readonly');
                        const store = transaction.objectStore(parsed.disk);
                        const request = store.get(parsed.path);
                        request.onsuccess = (event) => {
                            const file = event.target.result;
                            if (file) {
                                this.debugger('readFile', `Read file "${url}" successfully!`);
                                resolve(file.content);
                            } else {
                                this.debugger('readFile', `Failed to read file "${url}".`);
                                reject(`File not found: ${url}`);
                            }
                        };
                        request.onerror = (event) => {
                            reject(event.target.error);
                        };
                    });
                }

                // OK
                async mkdir(url) {
                    const parsed = this.parseURL(url);
                    return new Promise((resolve, reject) => {
                        const transaction = this.db.transaction(parsed.disk, 'readwrite');
                        const store = transaction.objectStore(parsed.disk);
                        const request = store.put({ path: parsed.path, type: 'directory' });
                        request.onsuccess = (event) => {
                            this.debugger('mkdir', `Directory "${url}" made successfully!`);
                            resolve();
                        };
                        request.onerror = (event) => {
                            this.debugger('mkdir', `Failed to make directory "${url}".`);
                            reject(event.target.error);
                        };
                    });
                }

                // OK
                async rm(url) {
                    const parsed = this.parseURL(url);
                    return new Promise((resolve, reject) => {
                        const transaction = this.db.transaction(parsed.disk, 'readwrite');
                        const store = transaction.objectStore(parsed.disk);
                        const request = store.delete(parsed.path);
                        request.onsuccess = (event) => {
                            this.debugger('rm', `Removed "${url}" successfully!`);
                            resolve();
                        };
                        request.onerror = (event) => {
                            this.debugger('rm', `Failed to remove "${url}".`);
                            reject(event.target.error);
                        };
                    });
                }

                // OK
                async mv(from, to) {
                    const parsedFrom = this.parseURL(from);
                    const parsedTo = this.parseURL(to);
                    return new Promise((resolve, reject) => {
                        // Read original file
                        const readTransaction = this.db.transaction(parsedFrom.disk, 'readwrite');
                        const readStore = readTransaction.objectStore(parsedFrom.disk);
                        const readRequest = readStore.get(parsedFrom.path);

                        readRequest.onsuccess = (event) => {
                            const file = event.target.result;
                            if (file) {
                                // Delete the original file
                                const deleteTransaction = this.db.transaction(parsedFrom.disk, 'readwrite');
                                const deleteStore = deleteTransaction.objectStore(parsedFrom.disk);
                                const deleteRequest = deleteStore.delete(parsedFrom.path);

                                deleteRequest.onsuccess = (event) => {
                                    file.path = parsedTo.path;
                                    // Put the file to the destination
                                    const putTransaction = this.db.transaction(parsedTo.disk, 'readwrite');
                                    const putStore = putTransaction.objectStore(parsedTo.disk);
                                    putStore.put(file);
                                    this.debugger('mv', `Moved "${from}" to "${to}" successfully!`);
                                    resolve();
                                }

                                deleteRequest.onerror = (event) => {
                                    this.debugger('mv', `Failed to delete "${from}".`);
                                    reject(event.target.error);
                                };
                            } else {
                                this.debugger('mv', `Failed to move "${from}" to "${to}".`);
                                reject(new Error(`File not found: ${from}`));
                            }
                        };

                        readRequest.onerror = (event) => {
                            reject(event.target.error);
                        };
                    });
                }

                // OK
                async readdir(url, deep = false) {
                    const parsed = this.parseURL(url);
                    return new Promise((resolve, reject) => {
                        const transaction = this.db.transaction(parsed.disk, 'readonly');
                        const store = transaction.objectStore(parsed.disk);
                        const request = store.index('path').openCursor() // getAll(IDBKeyRange.only(path));
                        var dirItems = [];
                        var isRoot = parsed.path == '' || !parsed.path;
                        request.onsuccess = (event) => {
                            const cursor = event.target.result;
                            if (cursor) {
                                var file = cursor.value;
                                if (!file.content) {
                                    file.content = new Blob();
                                }
                                if (deep == true) {
                                    if (isRoot || file.path.startsWith(`${parsed.path}/`)) {
                                        dirItems.push({
                                            path: parsed.disk + ':/' + file.path,
                                            type: file.type,
                                            mimeType: file.content.type
                                        });
                                    }
                                } else {
                                    if (isRoot && file.path.split('/').length == 1) {
                                        dirItems.push({
                                            path: parsed.disk + ':/' + file.path,
                                            type: file.type,
                                            mimeType: file.content.type
                                        });
                                    } else if (file.path.startsWith(`${parsed.path}/`) && file.path.replace(`${parsed.path}/`, '').indexOf('/') == -1) {
                                        dirItems.push({
                                            path: parsed.disk + ':/' + file.path,
                                            type: file.type,
                                            mimeType: file.content.type
                                        });
                                    }
                                }
                                cursor.continue();
                            } else {
                                this.debugger('readdir', `Read directory "${url}" successfully!`);
                                resolve(dirItems);
                            }
                            /*
                            const dirFiles = files.filter((file) => {
                                if (deep == true) {
                                    if (parsed.path == '' || !parsed.path) {
                                        return file;
                                    }
                                    return file.startsWith(`${parsed.path}/`);
                                } else {
                                    if (parsed.path == '' || !parsed.path) {
                                        return file.split('/').length == 1;
                                    }
                                    return file.replace(`${parsed.path}/`, '').split('/').length == 0;
                                }
                            });
                            this.debugger('readdir', `Read directory "${url}" successfully!`);
                            resolve(dirFiles);
                            */
                            // resolve(dirFiles.map((file) => file.path));
                        };
                        request.onerror = (event) => {
                            this.debugger('readdir', `Failed to read directory "${url}".`);
                            reject(event.target.error);
                        };
                    });
                }

                async exists(url) {
                    const parsed = this.parseURL(url);
                    return new Promise((resolve, reject) => {
                        if (parsed.path == '' || !parsed.path) {
                            if (this.disks.includes(parsed.disk)) {
                                resolve({
                                    exists: true,
                                    type: 'directory',
                                    content: new Blob()
                                });
                            } else {
                                resolve({
                                    exists: false,
                                    type: 'undefined',
                                    content: new Blob()
                                });
                            }
                        }
                        const transaction = this.db.transaction(parsed.disk, 'readonly');
                        const store = transaction.objectStore(parsed.disk);
                        const request = store.get(parsed.path);
                        request.onsuccess = (event) => {
                            const response = event.target.result;
                            if (response) {
                                this.debugger('exists', `"${url}" exists!`);
                                resolve({
                                    exists: true,
                                    type: response.type,
                                    content: response.content
                                });
                            } else {
                                this.debugger('exists', `"${url}" does not exist.`);
                                resolve({
                                    exists: false,
                                    type: 'undefined',
                                    content: new Blob()
                                });
                            }
                        };
                        request.onerror = (event) => {
                            this.debugger('exists', `Failed to check if "${url}" exists.`);
                            reject({
                                exists: event.target.error,
                                type: 'error',
                                content: new Blob()
                            });
                        };
                    });
                }
                async proxy(method, param, current) {
                    return new Promise((resolve, reject) => {
                        this[method].apply(this, param).then(response => {
                            resolve(response);
                        })
                    });
                }
                console = {
                    log(message) {
                        console.log('%c[IDBFS]', 'color: #f670ff', message);
                    }
                }
            }

            window.fs = new IDBFS('winbows11', mainDisk)
        })();

        window.fs.init();
        window.fs.downloadFile = downloadFile;

        async function downloadFile(path) {
            function removeStringInRange(str, start, end) {
                return str.substring(0, start) + str.substring(end);
            }

            return fetch(`./${removeStringInRange(path, 0, path.split(':/').length > 1 ? (path.split(':/')[0].length + 2) : 0)}`).then(response => {
                if (response.ok) {
                    return response.blob();
                } else {
                    throw new Error(`Failed to fetch file: ${path}`);
                }
            }).then(content => {
                var blob = content;
                fs.writeFile(path, blob);
                return;
            }).catch(async err => {
                console.log(`Failed to fetch file: ${path}`, err);
            })
        }

        var index = 0;
        var name = '';

        try {
            fetch('./tree.json').then(res => {
                return res.json();
            }).then(async files => {
                var lastTime = Date.now();
                var startTime = lastTime;
                var duration = 0;

                function predictTime() {
                    var avarageTime = (Date.now() - lastTime) / 2 / 1000;
                    var lastItems = files.length - index;
                    if (lastTime == startTime) {
                        return '計算中...';
                    } else {
                        return ~~(avarageTime * lastItems) + ' 秒';
                    }
                }

                function update() {
                    document.querySelector('.install-percent').innerHTML = ~~((index / files.length) * 100) + '% 已完成';
                    document.querySelector('.install-progress-bar').style.width = (index / files.length) * 100 + '%';
                    document.querySelector('.install-info').innerHTML = `名稱：${name}<br>剩餘時間：${predictTime()}<br>剩餘項目：${files.length - index}`;
                }
                setInterval(update, 1000);
                var installed = [];
                for (let i in files) {
                    index = i;
                    try {
                        name = files[i].split('/').slice(-1)
                    } catch (e) {
                        name = files[i]
                    }
                    update();
                    await fs.downloadFile(files[i]).then(() => {
                        var file = document.createElement('div');
                        file.className = 'install-detail-installed';
                        file.innerHTML = `<span>${files[i].replaceAll("<", "&lt;").replaceAll(">", "&gt;")}</span>`;
                        document.querySelector('.install-detail-installeds').appendChild(file);
                        document.querySelector('.install-details').scrollTop = document.querySelector('.install-detail-installeds').scrollHeight;
                        duration = Date.now() - startTime;
                        lastTime = startTime;
                        startTime = Date.now();
                        installed.push(files[i]);
                        localStorage.setItem('WINBOWS_DIRECTORIES', JSON.stringify(installed));
                    });
                }
                update();
                location.href = './';
            })
        } catch (e) { resolve(); }
    </script>
</body>

</html>