(()=>{"use strict";var __webpack_modules__={"./node_modules/css-loader/dist/cjs.js!./src/install/install.css":
/*!***********************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/install/install.css ***!
  \***********************************************************************/(module,__webpack_exports__,__webpack_require__)=>{eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `body {\r\n    margin: 0;\r\n    background: #000;\r\n    width: 100vw;\r\n    height: 100vh;\r\n    overflow: hidden;\r\n}\r\n\r\n.install {\r\n    width: 100vw;\r\n    height: 100vh;\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Oxygen-Sans, Ubuntu, Cantarell, \"Helvetica Neue\", sans-serif;\r\n}\r\n\r\n.install-window {\r\n    background: #fff;\r\n    border-radius: .5rem;\r\n    width: min(80vw, 720px);\r\n    height: min(80vh, 480px);\r\n    display: flex;\r\n    flex-direction: column;\r\n    overflow: hidden;\r\n}\r\n\r\n.install-progress,\r\n.install-details {\r\n    margin: 2rem 2rem 1.5rem;\r\n    position: relative;\r\n}\r\n\r\n.install-percent {\r\n    margin: 1.5rem 2rem 1rem;\r\n    font-weight: 600;\r\n    font-size: 1.25rem;\r\n}\r\n\r\n.install-progress {\r\n    background: #ddd;\r\n    margin-top: 0;\r\n    margin-bottom: 1rem;\r\n}\r\n\r\n.install-progress-bar {\r\n    background: #06b025;\r\n    height: 1.25rem;\r\n    display: block;\r\n    position: relative;\r\n    overflow: hidden;\r\n    width: 0%;\r\n}\r\n\r\n.install-progress-bar-peg {\r\n    width: 2rem;\r\n    height: 1.25rem;\r\n    background-color: transparent !important;\r\n    background: linear-gradient(to right, #fff0 0%, #fffa 50%, #fff0 100%);\r\n    position: absolute;\r\n    left: -100%;\r\n    top: 0;\r\n    animation: peg 5s linear infinite forwards;\r\n    animation-delay: 3s;\r\n}\r\n\r\n@keyframes peg {\r\n    0% {\r\n        left: -100%;\r\n    }\r\n\r\n    100% {\r\n        left: 100%;\r\n    }\r\n}\r\n\r\n.install-info {\r\n    padding: 0 2rem 1rem;\r\n    text-align: left;\r\n    font-size: .875rem;\r\n    color: #333;\r\n}\r\n\r\n.install-details {\r\n    overflow: auto;\r\n    max-height: -webkit-fill-available;\r\n    margin-top: 0rem;\r\n}\r\n\r\n.winui ::-webkit-scrollbar,\r\n.winui-light ::-webkit-scrollbar,\r\n[data-theme=\"dark\"] .winui ::-webkit-scrollbar,\r\n.winui-dark ::-webkit-scrollbar {\r\n    width: 14px;\r\n    height: 14px;\r\n    border-radius: 7px\r\n}\r\n\r\n.winui ::-webkit-scrollbar,\r\n.winui-light ::-webkit-scrollbar {\r\n    --scroll: rgb(255 255 255 / 80%);\r\n    --scrollbar-top-btn: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none'%3E%3Cpath d='M6.102 16.981c-1.074 0-1.648-1.265-.941-2.073l5.522-6.311a1.75 1.75 0 0 1 2.634 0l5.522 6.311c.707.808.133 2.073-.941 2.073H6.102z' fill='rgb(0 0 0 / 50%)'/%3E%3C/svg%3E\");\r\n    --scrollbar-right-btn: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none'%3E%3Cpath d='M9 17.898c0 1.074 1.265 1.648 2.073.941l6.311-5.522a1.75 1.75 0 0 0 0-2.634l-6.311-5.522C10.265 4.454 9 5.028 9 6.102v11.796z' fill='rgb(0 0 0 / 50%)'/%3E%3C/svg%3E\");\r\n    --scrollbar-bottom-btn: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none'%3E%3Cpath d='M6.102 8c-1.074 0-1.648 1.265-.941 2.073l5.522 6.311a1.75 1.75 0 0 0 2.634 0l5.522-6.311c.707-.808.133-2.073-.941-2.073H6.102z' fill='rgb(0 0 0 / 50%)'/%3E%3C/svg%3E\");\r\n    --scrollbar-left-btn: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none'%3E%3Cpath d='M15 17.898c0 1.074-1.265 1.648-2.073.941l-6.311-5.522a1.75 1.75 0 0 1 0-2.634l6.311-5.522c.808-.707 2.073-.133 2.073.941v11.796z' fill='rgb(0 0 0 / 50%)'/%3E%3C/svg%3E\");\r\n}\r\n\r\n[data-theme=\"dark\"] .winui ::-webkit-scrollbar,\r\n.winui-dark ::-webkit-scrollbar {\r\n    --scroll: rgb(44 44 44 / 25%);\r\n    --scrollbar-top-btn: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none'%3E%3Cpath d='M6.102 16.981c-1.074 0-1.648-1.265-.941-2.073l5.522-6.311a1.75 1.75 0 0 1 2.634 0l5.522 6.311c.707.808.133 2.073-.941 2.073H6.102z' fill='rgb(255 255 255 / 50%)'/%3E%3C/svg%3E\");\r\n    --scrollbar-right-btn: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none'%3E%3Cpath d='M9 17.898c0 1.074 1.265 1.648 2.073.941l6.311-5.522a1.75 1.75 0 0 0 0-2.634l-6.311-5.522C10.265 4.454 9 5.028 9 6.102v11.796z' fill='rgb(255 255 255 / 50%)'/%3E%3C/svg%3E\");\r\n    --scrollbar-bottom-btn: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none'%3E%3Cpath d='M6.102 8c-1.074 0-1.648 1.265-.941 2.073l5.522 6.311a1.75 1.75 0 0 0 2.634 0l5.522-6.311c.707-.808.133-2.073-.941-2.073H6.102z' fill='rgb(255 255 255 / 50%)'/%3E%3C/svg%3E\");\r\n    --scrollbar-left-btn: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none'%3E%3Cpath d='M15 17.898c0 1.074-1.265 1.648-2.073.941l-6.311-5.522a1.75 1.75 0 0 1 0-2.634l6.311-5.522c.808-.707 2.073-.133 2.073.941v11.796z' fill='rgb(255 255 255 / 50%)'/%3E%3C/svg%3E\")\r\n}\r\n\r\n.winui ::-webkit-scrollbar:vertical:hover,\r\n.winui-light ::-webkit-scrollbar:vertical:hover,\r\n.winui-dark ::-webkit-scrollbar:vertical:hover {\r\n    background: var(--scrollbar-bottom-btn) 0% calc(100% - 3px)/contain no-repeat, var(--scrollbar-top-btn) 0% calc(0% + 3px)/contain no-repeat, var(--scroll);\r\n}\r\n\r\n.winui ::-webkit-scrollbar:horizontal:hover,\r\n.winui-light ::-webkit-scrollbar:horizontal:hover,\r\n.winui-dark ::-webkit-scrollbar:horizontal:hover {\r\n    background: var(--scrollbar-right-btn) calc(100% - 3px) 0%/contain no-repeat, var(--scrollbar-left-btn) calc(0% + 3px) 0%/contain no-repeat, var(--scroll);\r\n}\r\n\r\n.winui ::-webkit-scrollbar-thumb,\r\n.winui-light ::-webkit-scrollbar-thumb {\r\n    display: none;\r\n    display: block;\r\n    background: rgba(0, 0, 0, .5);\r\n    background-clip: padding-box;\r\n    border: 6px solid transparent;\r\n    border-radius: 14px\r\n}\r\n\r\n[data-theme=dark] .winui ::-webkit-scrollbar-thumb,\r\n.winui-dark ::-webkit-scrollbar-thumb {\r\n    background: rgba(255, 255, 255, .5);\r\n    background-clip: padding-box;\r\n    border: 6px solid transparent;\r\n}\r\n\r\n.winui ::-webkit-scrollbar-thumb:hover,\r\n.winui-dark ::-webkit-scrollbar-thumb:hover,\r\n.winui-light ::-webkit-scrollbar-thumb:hover {\r\n    border: 4px solid transparent;\r\n    background-clip: padding-box;\r\n}\r\n\r\n.winui ::-webkit-scrollbar-button:single-button,\r\n.winui-dark ::-webkit-scrollbar-button:single-button,\r\n.winui-light ::-webkit-scrollbar-button:single-button {\r\n    height: 14px;\r\n}\r\n\r\n.winui :hover::-webkit-scrollbar-thumb,\r\n.winui-dark :hover::-webkit-scrollbar-thumb,\r\n.winui-light :hover::-webkit-scrollbar-thumb {\r\n    display: block;\r\n}`, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://winbows11/./src/install/install.css?./node_modules/css-loader/dist/cjs.js\n}")},"./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/module=>{eval('{\r\n\r\n/*\r\n  MIT License http://www.opensource.org/licenses/mit-license.php\r\n  Author Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function (cssWithMappingToString) {\r\n  var list = [];\r\n\r\n  // return the list of modules as css string\r\n  list.toString = function toString() {\r\n    return this.map(function (item) {\r\n      var content = "";\r\n      var needLayer = typeof item[5] !== "undefined";\r\n      if (item[4]) {\r\n        content += "@supports (".concat(item[4], ") {");\r\n      }\r\n      if (item[2]) {\r\n        content += "@media ".concat(item[2], " {");\r\n      }\r\n      if (needLayer) {\r\n        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");\r\n      }\r\n      content += cssWithMappingToString(item);\r\n      if (needLayer) {\r\n        content += "}";\r\n      }\r\n      if (item[2]) {\r\n        content += "}";\r\n      }\r\n      if (item[4]) {\r\n        content += "}";\r\n      }\r\n      return content;\r\n    }).join("");\r\n  };\r\n\r\n  // import a list of modules into the list\r\n  list.i = function i(modules, media, dedupe, supports, layer) {\r\n    if (typeof modules === "string") {\r\n      modules = [[null, modules, undefined]];\r\n    }\r\n    var alreadyImportedModules = {};\r\n    if (dedupe) {\r\n      for (var k = 0; k < this.length; k++) {\r\n        var id = this[k][0];\r\n        if (id != null) {\r\n          alreadyImportedModules[id] = true;\r\n        }\r\n      }\r\n    }\r\n    for (var _k = 0; _k < modules.length; _k++) {\r\n      var item = [].concat(modules[_k]);\r\n      if (dedupe && alreadyImportedModules[item[0]]) {\r\n        continue;\r\n      }\r\n      if (typeof layer !== "undefined") {\r\n        if (typeof item[5] === "undefined") {\r\n          item[5] = layer;\r\n        } else {\r\n          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");\r\n          item[5] = layer;\r\n        }\r\n      }\r\n      if (media) {\r\n        if (!item[2]) {\r\n          item[2] = media;\r\n        } else {\r\n          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");\r\n          item[2] = media;\r\n        }\r\n      }\r\n      if (supports) {\r\n        if (!item[4]) {\r\n          item[4] = "".concat(supports);\r\n        } else {\r\n          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");\r\n          item[4] = supports;\r\n        }\r\n      }\r\n      list.push(item);\r\n    }\r\n  };\r\n  return list;\r\n};\n\n//# sourceURL=webpack://winbows11/./node_modules/css-loader/dist/runtime/api.js?\n}')},"./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/module=>{eval("{\r\n\r\nmodule.exports = function (i) {\r\n  return i[1];\r\n};\n\n//# sourceURL=webpack://winbows11/./node_modules/css-loader/dist/runtime/noSourceMaps.js?\n}")},"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/module=>{eval('{\r\n\r\nvar stylesInDOM = [];\r\nfunction getIndexByIdentifier(identifier) {\r\n  var result = -1;\r\n  for (var i = 0; i < stylesInDOM.length; i++) {\r\n    if (stylesInDOM[i].identifier === identifier) {\r\n      result = i;\r\n      break;\r\n    }\r\n  }\r\n  return result;\r\n}\r\nfunction modulesToDom(list, options) {\r\n  var idCountMap = {};\r\n  var identifiers = [];\r\n  for (var i = 0; i < list.length; i++) {\r\n    var item = list[i];\r\n    var id = options.base ? item[0] + options.base : item[0];\r\n    var count = idCountMap[id] || 0;\r\n    var identifier = "".concat(id, " ").concat(count);\r\n    idCountMap[id] = count + 1;\r\n    var indexByIdentifier = getIndexByIdentifier(identifier);\r\n    var obj = {\r\n      css: item[1],\r\n      media: item[2],\r\n      sourceMap: item[3],\r\n      supports: item[4],\r\n      layer: item[5]\r\n    };\r\n    if (indexByIdentifier !== -1) {\r\n      stylesInDOM[indexByIdentifier].references++;\r\n      stylesInDOM[indexByIdentifier].updater(obj);\r\n    } else {\r\n      var updater = addElementStyle(obj, options);\r\n      options.byIndex = i;\r\n      stylesInDOM.splice(i, 0, {\r\n        identifier: identifier,\r\n        updater: updater,\r\n        references: 1\r\n      });\r\n    }\r\n    identifiers.push(identifier);\r\n  }\r\n  return identifiers;\r\n}\r\nfunction addElementStyle(obj, options) {\r\n  var api = options.domAPI(options);\r\n  api.update(obj);\r\n  var updater = function updater(newObj) {\r\n    if (newObj) {\r\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\r\n        return;\r\n      }\r\n      api.update(obj = newObj);\r\n    } else {\r\n      api.remove();\r\n    }\r\n  };\r\n  return updater;\r\n}\r\nmodule.exports = function (list, options) {\r\n  options = options || {};\r\n  list = list || [];\r\n  var lastIdentifiers = modulesToDom(list, options);\r\n  return function update(newList) {\r\n    newList = newList || [];\r\n    for (var i = 0; i < lastIdentifiers.length; i++) {\r\n      var identifier = lastIdentifiers[i];\r\n      var index = getIndexByIdentifier(identifier);\r\n      stylesInDOM[index].references--;\r\n    }\r\n    var newLastIdentifiers = modulesToDom(newList, options);\r\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\r\n      var _identifier = lastIdentifiers[_i];\r\n      var _index = getIndexByIdentifier(_identifier);\r\n      if (stylesInDOM[_index].references === 0) {\r\n        stylesInDOM[_index].updater();\r\n        stylesInDOM.splice(_index, 1);\r\n      }\r\n    }\r\n    lastIdentifiers = newLastIdentifiers;\r\n  };\r\n};\n\n//# sourceURL=webpack://winbows11/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?\n}')},"./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/module=>{eval('{\r\n\r\nvar memo = {};\r\n\r\n/* istanbul ignore next  */\r\nfunction getTarget(target) {\r\n  if (typeof memo[target] === "undefined") {\r\n    var styleTarget = document.querySelector(target);\r\n\r\n    // Special case to return head of iframe instead of iframe itself\r\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\r\n      try {\r\n        // This will throw an exception if access to iframe is blocked\r\n        // due to cross-origin restrictions\r\n        styleTarget = styleTarget.contentDocument.head;\r\n      } catch (e) {\r\n        // istanbul ignore next\r\n        styleTarget = null;\r\n      }\r\n    }\r\n    memo[target] = styleTarget;\r\n  }\r\n  return memo[target];\r\n}\r\n\r\n/* istanbul ignore next  */\r\nfunction insertBySelector(insert, style) {\r\n  var target = getTarget(insert);\r\n  if (!target) {\r\n    throw new Error("Couldn\'t find a style target. This probably means that the value for the \'insert\' parameter is invalid.");\r\n  }\r\n  target.appendChild(style);\r\n}\r\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://winbows11/./node_modules/style-loader/dist/runtime/insertBySelector.js?\n}')},"./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/module=>{eval('{\r\n\r\n/* istanbul ignore next  */\r\nfunction insertStyleElement(options) {\r\n  var element = document.createElement("style");\r\n  options.setAttributes(element, options.attributes);\r\n  options.insert(element, options.options);\r\n  return element;\r\n}\r\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://winbows11/./node_modules/style-loader/dist/runtime/insertStyleElement.js?\n}')},"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/(module,__unused_webpack_exports,__webpack_require__)=>{eval('{\r\n\r\n/* istanbul ignore next  */\r\nfunction setAttributesWithoutAttributes(styleElement) {\r\n  var nonce =  true ? __webpack_require__.nc : 0;\r\n  if (nonce) {\r\n    styleElement.setAttribute("nonce", nonce);\r\n  }\r\n}\r\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://winbows11/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?\n}')},"./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/module=>{eval('{\r\n\r\n/* istanbul ignore next  */\r\nfunction apply(styleElement, options, obj) {\r\n  var css = "";\r\n  if (obj.supports) {\r\n    css += "@supports (".concat(obj.supports, ") {");\r\n  }\r\n  if (obj.media) {\r\n    css += "@media ".concat(obj.media, " {");\r\n  }\r\n  var needLayer = typeof obj.layer !== "undefined";\r\n  if (needLayer) {\r\n    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");\r\n  }\r\n  css += obj.css;\r\n  if (needLayer) {\r\n    css += "}";\r\n  }\r\n  if (obj.media) {\r\n    css += "}";\r\n  }\r\n  if (obj.supports) {\r\n    css += "}";\r\n  }\r\n  var sourceMap = obj.sourceMap;\r\n  if (sourceMap && typeof btoa !== "undefined") {\r\n    css += "\\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");\r\n  }\r\n\r\n  // For old IE\r\n  /* istanbul ignore if  */\r\n  options.styleTagTransform(css, styleElement, options.options);\r\n}\r\nfunction removeStyleElement(styleElement) {\r\n  // istanbul ignore if\r\n  if (styleElement.parentNode === null) {\r\n    return false;\r\n  }\r\n  styleElement.parentNode.removeChild(styleElement);\r\n}\r\n\r\n/* istanbul ignore next  */\r\nfunction domAPI(options) {\r\n  if (typeof document === "undefined") {\r\n    return {\r\n      update: function update() {},\r\n      remove: function remove() {}\r\n    };\r\n  }\r\n  var styleElement = options.insertStyleElement(options);\r\n  return {\r\n    update: function update(obj) {\r\n      apply(styleElement, options, obj);\r\n    },\r\n    remove: function remove() {\r\n      removeStyleElement(styleElement);\r\n    }\r\n  };\r\n}\r\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://winbows11/./node_modules/style-loader/dist/runtime/styleDomAPI.js?\n}')},"./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/module=>{eval("{\r\n\r\n/* istanbul ignore next  */\r\nfunction styleTagTransform(css, styleElement) {\r\n  if (styleElement.styleSheet) {\r\n    styleElement.styleSheet.cssText = css;\r\n  } else {\r\n    while (styleElement.firstChild) {\r\n      styleElement.removeChild(styleElement.firstChild);\r\n    }\r\n    styleElement.appendChild(document.createTextNode(css));\r\n  }\r\n}\r\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://winbows11/./node_modules/style-loader/dist/runtime/styleTagTransform.js?\n}")},"./src/install/install.css":
/*!*********************************!*\
  !*** ./src/install/install.css ***!
  \*********************************/(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_install_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./install.css */ "./node_modules/css-loader/dist/cjs.js!./src/install/install.css");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\noptions.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");\noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_install_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_install_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_install_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_install_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);\n\n\n//# sourceURL=webpack://winbows11/./src/install/install.css?\n}')},"./src/install/install.js":
/*!********************************!*\
  !*** ./src/install/install.js ***!
  \********************************/(__webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("{__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _shared_fs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/fs.js */ \"./src/shared/fs.js\");\n/* harmony import */ var _install_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./install.css */ \"./src/install/install.css\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_shared_fs_js__WEBPACK_IMPORTED_MODULE_0__]);\n_shared_fs_js__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\r\n\r\n\r\nconst fs = new _shared_fs_js__WEBPACK_IMPORTED_MODULE_0__.IDBFS();\r\n\r\nvar index = 0;\r\nvar name = '';\r\nvar downloadedSize = 0;\r\n\r\nconst installEl = document.createElement('div');\r\nconst installWindow = document.createElement('div');\r\nconst installPercent = document.createElement('div');\r\nconst installProgress = document.createElement('div');\r\nconst installProgressBar = document.createElement('div');\r\nconst installProgressBarPeg = document.createElement('div');\r\nconst installInfo = document.createElement('div');\r\nconst installDetails = document.createElement('div');\r\nconst installDetailInstalleds = document.createElement('div');\r\ninstallEl.className = 'install winui';\r\ninstallWindow.className = 'install-window';\r\ninstallPercent.className = 'install-percent';\r\ninstallProgress.className = 'install-progress';\r\ninstallProgressBar.className = 'install-progress-bar';\r\ninstallProgressBarPeg.className = 'install-progress-bar-peg';\r\ninstallInfo.className = 'install-info';\r\ninstallDetails.className = 'install-details';\r\ninstallDetailInstalleds.className = 'install-detail-installeds';\r\ndocument.body.appendChild(installEl);\r\ninstallEl.appendChild(installWindow);\r\ninstallWindow.appendChild(installPercent);\r\ninstallWindow.appendChild(installProgress);\r\ninstallProgress.appendChild(installProgressBar);\r\ninstallProgressBar.appendChild(installProgressBarPeg);\r\ninstallWindow.appendChild(installInfo);\r\ninstallWindow.appendChild(installDetails);\r\ninstallDetails.appendChild(installDetailInstalleds);\r\n\r\nasync function downloadFile(path) {\r\n    function removeStringInRange(str, start, end) {\r\n        return str.substring(0, start) + str.substring(end);\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n        fetch(`./${removeStringInRange(path, 0, path.split(':/').length > 1 ? (path.split(':/')[0].length + 2) : 0)}?timestamp=${new Date().getTime()}`).then(response => {\r\n            if (response.ok) {\r\n                return response.blob();\r\n            } else {\r\n                throw new Error(`Failed to fetch file: ${path}`);\r\n            }\r\n        }).then(async content => {\r\n            var blob = content;\r\n            await fs.writeFile(path, blob);\r\n            downloadedSize += blob.size;\r\n            return resolve();\r\n        }).catch(async err => {\r\n            console.log(`Failed to fetch file: ${path}`, err);\r\n            installWindow.style.alignItems = 'center';\r\n            installWindow.style.justifyContent = 'center';\r\n            installWindow.innerHTML = `<svg xmlns=\"http://www.w3.org/2000/svg\" style=\"width:5rem;height:5rem;\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"#E69264\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3\"></path><path d=\"M12 9v4\"></path><path d=\"M12 17h.01\"></path></svg><div style= \"max-width: 60%;word-break: break-all;font-weight: 600;font-size: 1.25rem;margin-top: 1rem;\">An error occurred and cannot be downloaded ${name}</div> <div style=\"font-size: .875rem;color: #454545;margin: .375rem;\">It is recommended that you download in a place with a stable network connection</div><br><a href=\"./\" style=\"color: #fff;margin-bottom: .5rem;padding: .75rem 1.25rem;background: #0067c0;border-radius: .5rem;text-decoration: none;cursor: pointer;user-select:none; -webkit-user-select:none;-webkit-user-drag:none;\">Re-execute Winbows11?</a>`;\r\n            return reject(err);\r\n        })\r\n    })\r\n}\r\n\r\ntry {\r\n    fetch(`./build.json?timestamp=${new Date().getTime()}`).then(res => {\r\n        return res.json();\r\n    }).then(async data => {\r\n        // Clear configs\r\n        localStorage.removeItem('WINBOWS_SYSTEM_FV_VIEWERS');\r\n        localStorage.removeItem('WINBOWS_SYSTEM_FV_DEFAULT_VIEWERS');\r\n        localStorage.removeItem('WINBOWS_SYSTEM_FV_REGISTERED_VIEWERS');\r\n\r\n        // Remove Temp Files\r\n        try {\r\n            await fs.rm('%temp%');\r\n        } catch (err) {\r\n            console.error('Failed to remove temp files:', err);\r\n        }\r\n\r\n        var startTime = Date.now();\r\n\r\n        var installed = [];\r\n\r\n        const nameElement = document.createElement('div');\r\n        const timeElement = document.createElement('div');\r\n        const lastElement = document.createElement('div');\r\n\r\n        const files = data.table;\r\n        const build_id = data.build_id;\r\n        const size = data.size;\r\n\r\n        console.log('Whole size: ' + formatBytes(size).replaceAll('(', '').replaceAll(')', ''));\r\n\r\n        nameElement.innerHTML = 'Name: unknown';\r\n        timeElement.innerHTML = 'Remaining times: unknown';\r\n        lastElement.innerHTML = 'Remaining items: unknown';\r\n\r\n        installInfo.appendChild(nameElement);\r\n        installInfo.appendChild(timeElement);\r\n        installInfo.appendChild(lastElement);\r\n\r\n        function predictTime() {\r\n            if (installed.length == 0) {\r\n                return 'Calculating...';\r\n            }\r\n            const now = Date.now();\r\n            const ds = (now - startTime) / 1000;\r\n            const bytesPerSecond = downloadedSize / ds;\r\n            const seconds = ~~((size - downloadedSize) / bytesPerSecond);\r\n            if (seconds < 60) {\r\n                return `${seconds} sencond(s)`;\r\n            } else if (seconds < 60 * 60) {\r\n                return `${~~(seconds / 60)} minute(s) and ${seconds % 60} sencond(s)`;\r\n            } else if (seconds < 60 * 60 * 24) {\r\n                return `${~~(seconds / (60 * 60))} hour(s)`;\r\n            } else {\r\n                return 'more than one day';\r\n            }\r\n        }\r\n\r\n        function formatBytes(bytes, decimals = 2) {\r\n            if (bytes === 0 || !bytes) return '';\r\n\r\n            const k = 1024;\r\n            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\r\n            const i = Math.floor(Math.log(bytes) / Math.log(k));\r\n\r\n            return '(' + parseFloat((bytes / Math.pow(k, i)).toFixed(decimals)) + ' ' + sizes[i] + ')';\r\n        }\r\n\r\n        function updateItem() {\r\n            installPercent.innerHTML = ~~((index / (files.length - 1)) * 100) + '% complete';\r\n            installProgressBar.style.width = (index / (files.length - 1)) * 100 + '%';\r\n            nameElement.innerHTML = `Name: ${name}`;\r\n\r\n            let remainingSize = size - downloadedSize;\r\n            if (remainingSize < 0) {\r\n                remainingSize = 0;\r\n            }\r\n            lastElement.innerHTML = `Remaining items: ${files.length - index - 1} ${formatBytes(remainingSize)}`;\r\n        }\r\n        function updateTime() {\r\n            updateItem();\r\n            timeElement.innerHTML = `Remaining times: ${predictTime()}`;\r\n        }\r\n        function update() {\r\n            updateTime();\r\n        }\r\n        setInterval(update, 1000);\r\n        update();\r\n        for (let i in files) {\r\n            index = i;\r\n            try {\r\n                name = files[i].split('/').slice(-1)\r\n            } catch (e) {\r\n                name = files[i]\r\n            }\r\n            updateItem();\r\n            await downloadFile(files[i]).then(() => {\r\n                var file = document.createElement('div');\r\n                file.className = 'install-detail-installed';\r\n                file.innerHTML = `<span>${files[i].replaceAll(\"<\", \"&lt;\").replaceAll(\">\", \"&gt;\")}</span>`;\r\n                installDetailInstalleds.appendChild(file);\r\n                installDetails.scrollTop = installDetailInstalleds.scrollHeight;\r\n                installed.push(files[i]);\r\n\r\n                console.log(formatBytes(downloadedSize).replaceAll('(', '').replaceAll(')', ''));\r\n\r\n                if (installed.length == files.length) {\r\n                    localStorage.setItem('WINBOWS_BUILD_ID', build_id);\r\n                    update();\r\n                    location.href = './';\r\n                }\r\n            });\r\n        }\r\n    })\r\n} catch (e) { resolve(); }\r\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://winbows11/./src/install/install.js?\n}")},"./src/shared/fs.js":
/*!**************************!*\
  !*** ./src/shared/fs.js ***!
  \**************************/(__webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("{__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IDBFS: () => (/* binding */ IDBFS),\n/* harmony export */   fsUtils: () => (/* binding */ fsUtils)\n/* harmony export */ });\nconst debugMode = false;\r\nconst defaultEnv = {\r\n    APPDATA: 'C:/User/AppData/Roaming',\r\n    LOCALAPPDATA: 'C:/User/AppData/Local',\r\n    PROGRAMFILES: 'C:/Program Files',\r\n    SYSTEMDRIVE: 'C:',\r\n    SYSTEMROOT: 'C:/Winbows',\r\n    TEMP: 'C:/User/AppData/Local/Temp',\r\n    TMP: 'C:/User/AppData/Local/Temp',\r\n    USERPROFILE: 'C:/User',\r\n    WINDIR: 'C:/Winbows',\r\n};\r\n\r\n// --------------------------- Utils --------------------------- //\r\nfunction getStackTrace() {\r\n    var stack;\r\n    try {\r\n        throw new Error('');\r\n    } catch (error) {\r\n        stack = error.stack || '';\r\n    }\r\n    stack = stack.split('\\n').map(function (line) { return line.trim(); });\r\n    return stack.splice(stack[0] == 'Error' ? 2 : 1);\r\n}\r\nfunction getJsonFromURL(url) {\r\n    if (!url) url = location.search;\r\n    var query = url.substr(1), result = {};\r\n    query.split(\"&\").forEach(function (part) {\r\n        var item = part.split(\"=\");\r\n        result[item[0]] = decodeURIComponent(item[1]);\r\n    });\r\n    return result;\r\n};\r\nfunction computePath(path, currentPath) {\r\n    const currentPathDirs = currentPath.split('/').filter(dir => dir !== ''),\r\n        pathDirs = path.split('/').filter(dir => dir !== ''),\r\n        resultPath = [...currentPathDirs];\r\n    for (const dir of pathDirs) {\r\n        if (dir === '..') {\r\n            if (resultPath.length > 0) { resultPath.pop(); }\r\n        } else if (dir !== '.') { resultPath.push(dir); }\r\n    }\r\n    return resultPath.join('/');\r\n};\r\nfunction removeStringInRange(str, start, end) {\r\n    return str.substring(0, start) + str.substring(end);\r\n};\r\nfunction randomID(count, chars) {\r\n    var chars = chars || 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',\r\n        result = '',\r\n        length = chars.length;\r\n    for (let i = 0; i < count; i++) {\r\n        result += chars.charAt(Math.floor(Math.random() * length));\r\n    }\r\n    return result;\r\n};\r\nfunction isBlob(obj) {\r\n    return Object.prototype.toString.call(obj) === \"[object Blob]\"\r\n};\r\nconst fsUtils = {\r\n    sep: '/',\r\n    normalize(p) {\r\n        const parts = p.split(/[/\\\\]+/);\r\n        const stack = [];\r\n\r\n        for (let part of parts) {\r\n            if (part === '' || part === '.') continue;\r\n            if (part === '..') stack.pop();\r\n            else stack.push(part);\r\n        }\r\n\r\n        return (p.startsWith('/') ? '/' : '') + stack.join('/');\r\n    },\r\n    join(...args) {\r\n        return fsUtils.normalize(args.join('/'));\r\n    },\r\n    resolve(...paths) {\r\n        let resolved = '';\r\n        for (let i = paths.length - 1; i >= 0; i--) {\r\n            const p = paths[i];\r\n            if (!p) continue;\r\n            resolved = p + '/' + resolved;\r\n            if (fsUtils.isAbsolute(p)) break;\r\n        }\r\n        return fsUtils.normalize(resolved);\r\n    },\r\n    dirname(p) {\r\n        const normalized = fsUtils.normalize(p);\r\n        const parts = normalized.split('/');\r\n        parts.pop();\r\n        return fsUtils.toDirFormat(parts.length > 1 ? parts.join('/') : '/');\r\n    },\r\n    basename(p) {\r\n        return fsUtils.normalize(p).split('/').pop();\r\n    },\r\n    extname(p) {\r\n        const base = fsUtils.basename(p);\r\n        const dotIndex = base.lastIndexOf('.');\r\n        return dotIndex > 0 ? base.slice(dotIndex) : '';\r\n    },\r\n    isAbsolute(p) {\r\n        return p.startsWith('/') || /^[A-Za-z]:[\\\\/]/.test(p);\r\n    },\r\n    relative(from, to) {\r\n        const fromParts = fsUtils.resolve(from).split('/');\r\n        const toParts = fsUtils.resolve(to).split('/');\r\n\r\n        while (fromParts.length && toParts.length && fromParts[0] === toParts[0]) {\r\n            fromParts.shift();\r\n            toParts.shift();\r\n        }\r\n\r\n        return '../'.repeat(fromParts.length) + toParts.join('/');\r\n    },\r\n    parsePath(v) {\r\n        v = v.replaceAll('\\\\', '/');\r\n        const match = /^([a-zA-Z]):\\//.exec(v);\r\n        const disk = match ? match[1].toUpperCase() : 'C';\r\n        let path = v.replace(/^([a-zA-Z]):/, '');\r\n        path = fsUtils.normalize(path);\r\n        path = !path.endsWith('/') && v.endsWith('/') ? path + '/' : path;;\r\n        return { disk, path };\r\n    },\r\n    toDirFormat(path) {\r\n        return path.endsWith('/') ? path : path + '/';\r\n    },\r\n    isValidAbsolutePath(path) {\r\n        const p = path.replace(/\\\\/g, '/');\r\n\r\n        if (!/^[a-zA-Z]{1}:\\//.test(p)) return false;\r\n\r\n        const parts = p.split('/');\r\n        let depth = 0;\r\n        for (const part of parts.slice(1)) {    // Ignore disk\r\n            if (part === '' || part === '.') continue;\r\n            else if (part === '..') {\r\n                depth--;\r\n                if (depth < 0) return false;\r\n            } else {\r\n                depth++;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    },\r\n    resolveEnvPath(path) {\r\n        return path.replace(/^%([^%]+)%[\\\\/]?/, (_, key) => {\r\n            const value = defaultEnv[key.toUpperCase()];\r\n            return value ? value + '/' : `%${key}%/`;\r\n        });\r\n    }\r\n};\r\n// --------------------------- Utils --------------------------- //\r\n\r\n// UUID\r\nconst UUIDManager = (function () {\r\n    const uuids = new Map();\r\n    const priorities = {\r\n        \"~BOOT\": 10,\r\n        \"~KERNEL\": 9,\r\n        \"~SYSTEM\": 9,\r\n        \"~EXPLORER\": 8\r\n    }\r\n\r\n    function UUID() {\r\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n            var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\r\n            return v.toString(16);\r\n        });\r\n    }\r\n\r\n    function setupUUIDPriority(uuid, caller) {\r\n        if (typeof caller === \"string\") {\r\n            const priority = priorities[caller]\r\n            uuids.set(uuid, priority !== undefined ? priority : 0);\r\n        } else {\r\n            uuids.set(uuid, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {String} uuid \r\n     * @returns {Number|null} if uuid doesn't exist returns null\r\n     */\r\n    function getPriority(uuid) {\r\n        const priority = uuids.get(uuid);\r\n        return (priority != undefined && priority >= 0) ? priority : null;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {String} caller \r\n     * @returns \r\n     */\r\n    function register(caller) {\r\n        const uuid = UUID();\r\n        setupUUIDPriority(uuid, caller);\r\n        return uuid;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {String} uuid \r\n     */\r\n    function deregister(uuid) {\r\n        if (uuids.has(uuid)) {\r\n            uuids.delete(uuid);\r\n        } else {\r\n            console.error(new Error(\"Invalid uuid.\"));\r\n        }\r\n    }\r\n\r\n    return { register, getPriority, deregister };\r\n})();\r\n\r\nclass TransactionQueue {\r\n    constructor(maxConcurrent = 1) {\r\n        this.maxConcurrent = maxConcurrent;\r\n        this.currentCount = 0;\r\n        this.queue = [];\r\n    }\r\n\r\n    enqueue(task, uuid) {\r\n        return new Promise((resolve, reject) => {\r\n            const job = { priority: UUIDManager.getPriority(uuid), task, resolve, reject, uuid };\r\n            this.queue.push(job);\r\n            this.queue.sort((a, b) => b.priority - a.priority);\r\n            this.tryNext();\r\n        });\r\n    }\r\n    tryNext() {\r\n        if (this.currentCount >= this.maxConcurrent) return;\r\n        if (this.queue.length === 0) return;\r\n\r\n        const job = this.queue.shift();\r\n        this.currentCount++;\r\n\r\n        if (UUIDManager.getPriority(job.uuid) == null) {\r\n            this.currentCount--;\r\n            job.reject(new Error(\"The specified file system uuid cannot be found.\"));\r\n            this.tryNext();\r\n        }\r\n\r\n        Promise.resolve()\r\n            .then(() => job.task())\r\n            .then(result => {\r\n                this.currentCount--;\r\n                job.resolve(result);\r\n                this.tryNext();\r\n            })\r\n            .catch(err => {\r\n                this.currentCount--;\r\n                job.reject(err);\r\n                this.tryNext();\r\n            });\r\n    }\r\n}\r\n\r\nconst types = {\r\n    dir: 0,\r\n    file: 1\r\n};\r\nconst dbName = 'WINBOWS_STORAGE';\r\nconst storeName = 'MAIN';\r\nconst fileTablePrefix = '$_FILETABLE_';\r\nconst localStoragePrefix = dbName + '_' + fileTablePrefix;\r\nconst idLength = 24;\r\nconst allowedDiskName = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\r\nconst schemaVersion = 1;\r\nconst schemaVersionName = dbName + '_' + 'SCHEMA_VERSION';\r\n\r\nconst txQueue = new TransactionQueue(5);\r\nlet runningTasks = 0;\r\nlet tasks = [];\r\nlet updateTimer = null;\r\nconst maxConcurrent = 10;\r\nconst updateDelay = 100;\r\n\r\nlet listeners = {};\r\nlet blobURLCaches = {};\r\n\r\nvar version = 1;\r\nvar isInitializing = false;\r\nvar repairing = false;\r\nvar now = Date.now();\r\nvar fileTables = {\r\n    'C': {\r\n        '/': {\r\n            type: types.dir,\r\n            changeTime: now,\r\n            createdTime: now,\r\n            lastModifiedTime: now,\r\n            length: 0,\r\n            id: null,\r\n            mimeType: null\r\n        }\r\n    }\r\n};\r\nvar db;\r\n\r\n// Read from localStorage\r\nfor (let i = 0; i < localStorage.length; i++) {\r\n    const key = localStorage.key(i);\r\n    // localStorage item name : \"<localStoragePrefix><DiskName>:\"\r\n    if (key.startsWith(localStoragePrefix) && key.length === localStoragePrefix.length + 2) {\r\n        const disk = key.replace(localStoragePrefix, '').replace(':', '');\r\n        if (allowedDiskName.indexOf(disk) > -1 && disk.length === 1) {\r\n            try {\r\n                fileTables[disk] = JSON.parse(localStorage.getItem(key));\r\n            } catch (e) {\r\n                localStorage.removeItem(key);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Save the schema version in localStorage\r\nlocalStorage.setItem(schemaVersionName, schemaVersion);\r\n\r\n// ========================== Output ========================== //\r\nfunction print(...obj) {\r\n    if (debugMode == true) {\r\n        console.log.apply(arguments, ['%cIDBFS', 'color:#ff00ff;'].concat(obj))\r\n    }\r\n}\r\n\r\n// ========================== Event ========================== //\r\nfunction on(event, listener) {\r\n    if (!listeners[event]) {\r\n        listeners[event] = [];\r\n    }\r\n    listeners[event].push(listener);\r\n}\r\n\r\nfunction emit(event, detail) {\r\n    if (listeners[event]) {\r\n        listeners[event].forEach(listener => listener(detail));\r\n    }\r\n}\r\n\r\n// ======================== Validators ======================== //\r\nasync function ensureParentFolders(disk, path) {\r\n    const parts = path.split('/').filter(i => i.trim().length > 0);\r\n    parts.pop();\r\n\r\n    let currentPath = '/';\r\n    for (const part of parts) {\r\n        currentPath += part + '/';\r\n        if (!fileTables[disk][currentPath]) {\r\n            const now = Date.now();\r\n            fileTables[disk][currentPath] = {\r\n                type: types.dir,\r\n                changeTime: now,\r\n                createdTime: now,\r\n                lastModifiedTime: now,\r\n                length: 0,\r\n                id: null,\r\n                mimeType: null\r\n            };\r\n        }\r\n    }\r\n}\r\n\r\n// =========================== Store =========================== //\r\nasync function getStore(permission, uuid) {\r\n    return new Promise((resolve, reject) => {\r\n        tasks.push({ permission, resolve, reject, uuid, priority: UUIDManager.getPriority(uuid) });\r\n        tasks.sort((a, b) => b.priority - a.priority);\r\n        doTask();\r\n    })\r\n}\r\n\r\nasync function doTask() {\r\n    if (runningTasks >= maxConcurrent) return;\r\n    if (tasks.length === 0) {\r\n        if (runningTasks === 0) repairing = false;\r\n        return;\r\n    }\r\n\r\n    runningTasks++;\r\n    const task = tasks.shift();\r\n\r\n    if (UUIDManager.getPriority(task.uuid) == null) {\r\n        task.reject(`The specified file system uuid cannot be found.`);\r\n        runningTasks--;\r\n        doTask();\r\n        return;\r\n    }\r\n\r\n    try {\r\n        const tx = db.transaction(storeName, task.permission);\r\n        const store = tx.objectStore(storeName);\r\n        task.resolve(store);\r\n\r\n        tx.oncomplete = () => {\r\n            runningTasks--;\r\n            doTask();\r\n        };\r\n        tx.onerror = () => {\r\n            runningTasks--;\r\n            task.reject(tx.error);\r\n            doTask();\r\n        };\r\n\r\n        if (repairing == true) repairing = false;\r\n    } catch (e) {\r\n        runningTasks--;\r\n        if (repairing == false) {\r\n            repairing = true;\r\n            await init();\r\n            print('Trying to repair idbfs...');\r\n            tasks.unshift(task);\r\n            return doTask();\r\n        } else if (e.name === 'InvalidStateError' && repairing == true) {\r\n            print('Failed to repair idbfs.');\r\n        }\r\n    }\r\n}\r\n\r\nasync function createStore() {\r\n    if (!db) {\r\n        await init();\r\n    }\r\n    return new Promise((resolve) => {\r\n        const request = indexedDB.open(dbName, db.version + 1);\r\n        request.onupgradeneeded = (event) => {\r\n            print('Upgrading database to version', event.oldVersion, 'to', event.newVersion);\r\n            const db = event.target.result;\r\n            if (!db.objectStoreNames.contains(storeName)) {\r\n                const store = db.createObjectStore(storeName, { keyPath: 'k' });\r\n                store.createIndex('k', 'k', { unique: true });\r\n            }\r\n        };\r\n        request.onsuccess = (event) => {\r\n            db = event.target.result;\r\n            resolve(true);\r\n        };\r\n    });\r\n}\r\n\r\nfunction put(store, data) {\r\n    return new Promise((resolve, reject) => {\r\n        const req = store.put(data);\r\n        req.onsuccess = resolve;\r\n        req.onerror = () => reject(req.error);\r\n    });\r\n}\r\n\r\n// ========================= File table ========================= //\r\nasync function updateFileTable(disk) {\r\n    localStorage.setItem(localStoragePrefix + disk + ':', JSON.stringify(fileTables[disk]));\r\n    scheduleUpdateFileTable(disk);\r\n}\r\n\r\n// For idb\r\nfunction scheduleUpdateFileTable(disk) {\r\n    if (updateTimer) clearTimeout(updateTimer);\r\n    updateTimer = setTimeout(async () => {\r\n        updateTimer = null;\r\n        try {\r\n            const tx = db.transaction(storeName, 'readwrite');\r\n            const store = tx.objectStore(storeName);\r\n            store.put({\r\n                k: fileTablePrefix + disk + ':',\r\n                v: fileTables[disk]\r\n            })\r\n        } catch (e) {\r\n            console.warn('Failed to update fileTable in IndexedDB:', e);\r\n        }\r\n    }, updateDelay);\r\n}\r\n\r\nasync function deleteBlobsInBatches(disk, paths, uuid, batchSize = 100) {\r\n    for (let i = 0; i < paths.length; i += batchSize) {\r\n        const batch = paths.slice(i, i + batchSize);\r\n        const store = await getStore('readwrite', uuid);\r\n\r\n        await Promise.all(batch.map(path => {\r\n            return new Promise((res, rej) => {\r\n                const entry = fileTables[disk][path];\r\n                if (!entry || entry.type !== types.file) return res();\r\n\r\n                const req = store.delete(entry.id);\r\n                req.onsuccess = () => {\r\n                    // Remove cached url\r\n                    if (blobURLCaches[disk + ':' + path]) {\r\n                        delete blobURLCaches[disk + ':' + path];\r\n                    }\r\n                    delete fileTables[disk][path];\r\n                    res();\r\n                };\r\n                req.onerror = () => {\r\n                    console.warn(`Failed to delete blob for ${path}:`, req.error);\r\n                    res();\r\n                }\r\n            });\r\n        }));\r\n        await updateFileTable(disk);\r\n    }\r\n}\r\n\r\nasync function init() {\r\n    if (isInitializing) return;\r\n    isInitializing = true;\r\n    return new Promise((resolve, reject) => {\r\n        const request = indexedDB.open(dbName);\r\n        request.onupgradeneeded = (event) => {\r\n            print('Upgrading database to version', event.oldVersion, 'to', event.newVersion);\r\n            db = event.target.result;\r\n            const store = db.createObjectStore(storeName, { keyPath: 'k' });\r\n            store.createIndex('k', 'k', { unique: true });\r\n        };\r\n        request.onsuccess = async (event) => {\r\n            isInitializing = false;\r\n\r\n            db = event.target.result;\r\n            db.onversionchange = function () {\r\n                db.close();\r\n            };\r\n            if (!event.target.result.objectStoreNames.contains(storeName)) {\r\n                await createStore();\r\n            }\r\n\r\n            async function getOrSyncFileTable(disk) {\r\n                const key = fileTablePrefix + disk + ':';\r\n                const localStorageFT = localStorage.getItem(localStoragePrefix + disk + ':');\r\n                return new Promise((resolve, reject) => {\r\n                    const tx = db.transaction(storeName, 'readwrite')\r\n                    const store = tx.objectStore(storeName);\r\n                    const request = store.get(key);\r\n                    request.onsuccess = async (event) => {\r\n                        // NOTE: Use the file table in localStorage first\r\n                        const table = event.target.result;\r\n                        if (localStorageFT) {\r\n                            // Sync the file table in localStorage to the file table in idbfs\r\n                            try {\r\n                                await put(store, {\r\n                                    k: key,\r\n                                    v: JSON.parse(localStorageFT)\r\n                                });\r\n                            } catch (e) {\r\n                                print('Error : Failed to Sync the file table in localStorage to the file table in idbfs\\nDetails :', e);\r\n                                localStorage.removeItem(localStoragePrefix + disk + ':');\r\n                            }\r\n                        } else if (table && !localStorageFT) {\r\n                            // File table doesn't exist in localStorage\r\n                            fileTables[disk] = table.v;\r\n                            localStorage.setItem(localStoragePrefix + disk + ':', JSON.stringify(fileTables[disk]));\r\n                        } else if (!table && !localStorageFT) {\r\n                            // File table doesn't exist in localStorage or idbfs\r\n                            localStorage.setItem(localStoragePrefix + disk + ':', JSON.stringify(fileTables[disk]));\r\n                            await put(store, {\r\n                                k: key,\r\n                                v: fileTables[disk]\r\n                            });\r\n                        }\r\n                        resolve();\r\n                    }\r\n                    request.onerror = async (event) => {\r\n                        print(`Warning : Failed to get file table [${fileTablePrefix + disk + ':'}] from idbfs\\nDetails :`, event.target.error);\r\n                        const localStorageFT = localStorage.getItem(localStoragePrefix + disk + ':');\r\n                        try {\r\n                            await put(store, {\r\n                                k: fileTablePrefix + disk + ':',\r\n                                v: localStorageFT ? JSON.parse(localStorageFT) : fileTables[disk]\r\n                            });\r\n                        } catch (e) {\r\n                            print('Error : Failed to write file table to idbfs\\nDetails :', e);\r\n                        }\r\n                        resolve();\r\n                    }\r\n                })\r\n            }\r\n\r\n            // Try to read the file table\r\n            for (const disk of Object.keys(fileTables)) {\r\n                await getOrSyncFileTable(disk);\r\n            }\r\n            resolve();\r\n        };\r\n        request.onerror = (event) => {\r\n            isInitializing = false;\r\n            reject(event.target.error);\r\n        };\r\n    })\r\n}\r\n\r\nawait init();\r\n\r\nconst IDBFS = function (caller = \"<anonymous>\", __dirname = \"\") {\r\n    const uuid = UUIDManager.register(caller);\r\n\r\n    function parsePath(v) {\r\n        v = fsUtils.resolveEnvPath(v);\r\n        if (__dirname != \"\") {\r\n            var isdir = v.endsWith('/');\r\n            v = fsUtils.resolve(__dirname, v);\r\n            if (isdir) v += '/';\r\n        }\r\n        v = v.replaceAll('\\\\', '/');\r\n        const match = /^([a-zA-Z]):\\//.exec(v);\r\n        const disk = match ? match[1].toUpperCase() : 'C';\r\n        let path = v.replace(/^([a-zA-Z]):/, '');\r\n        path = fsUtils.normalize(path);\r\n        path = !path.endsWith('/') && v.endsWith('/') ? path + '/' : path;\r\n        return { disk, path };\r\n    };\r\n\r\n    // ================== Basic File System functions ================== //\r\n\r\n    /**\r\n     * @typedef {Object} CustomError\r\n     * @property {string} name \r\n     * @property {string} message\r\n     * @property {number} code\r\n     */\r\n\r\n    /**\r\n     * Check if the specified file / directory path exists\r\n     * @param {string} fullPath \r\n     * @returns {boolean}\r\n     */\r\n    function exists(fullPath) {\r\n        const { disk, path } = parsePath(fullPath);\r\n        if (!fileTables[disk]) {\r\n            return false;\r\n        }\r\n        return !!fileTables[disk][path];\r\n    }\r\n\r\n    /**\r\n     * Create a directory\r\n     * @param {string} fullPath \r\n     * @returns {Promise} If it failed, reject a {@link CustomError}\r\n     */\r\n    async function mkdir(fullPath) {\r\n        // RULE : directory path should end with '/'\r\n        const { disk, path: rawPath } = parsePath(fullPath);\r\n        let path = rawPath.endsWith('/') ? rawPath : rawPath + '/';\r\n\r\n        const invalidFolderNamePattern = /[\\\\\\/:\\*\\?\"<>\\|]|[\\. ]$/;\r\n        if (invalidFolderNamePattern.test(fsUtils.basename(fullPath)) && path != '/') {\r\n            // Check if the directory name contains invalid characters\r\n            throw {\r\n                name: 'InvalidName',\r\n                message: `Illegal directory name : ${fullPath}`\r\n            };\r\n        } else if (!fileTables[disk]) {\r\n            // Check if the target disk exists\r\n            throw {\r\n                name: 'NotFound',\r\n                message: `Invalid path : ${fullPath}`\r\n            };\r\n        } /*else if (!checkParentFoldersExist(disk, path)) {\r\n                // Check if the parent folder exists\r\n                throw {\r\n                    name: 'NotFound',\r\n                    message: `No such file or directory : ${fullPath}`\r\n                };\r\n            } */else if (fileTables[disk][path]) {\r\n            // Check if the directory already exists\r\n            throw {\r\n                name: 'AlreadyExists',\r\n                message: `Directory already exists : ${fullPath}`\r\n            };\r\n        } else {\r\n            ensureParentFolders(disk, path);\r\n            const now = Date.now();\r\n            fileTables[disk][path] = {\r\n                type: types.dir,\r\n                changeTime: now,\r\n                createdTime: now,\r\n                lastModifiedTime: now,\r\n                length: 0,\r\n                id: null,\r\n                mimeType: null\r\n            }\r\n            updateFileTable(disk);\r\n            emit('change', {\r\n                path: fullPath\r\n            })\r\n            return;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Move file or directory\r\n     * @param {string} srcFullPath \r\n     * @param {string} destFullPath \r\n     * @param {object} [options]\r\n     * @param {boolean} [options.overwrite=false]\r\n     */\r\n    async function mv(srcFullPath, destFullPath, options = {}) {\r\n        const { overwrite = false } = options;\r\n\r\n        const { disk: srcDisk, path: srcPath } = parsePath(srcFullPath);\r\n        const { disk: destDisk, path: destPath } = parsePath(destFullPath);\r\n\r\n        if (!fileTables[srcDisk] || !fileTables[srcDisk][srcPath]) {\r\n            throw { name: 'NotFound', message: `Source path not found: ${srcFullPath}` };\r\n        }\r\n        if (!fileTables[destDisk]) {\r\n            throw { name: 'NotFound', message: `Destination disk not found: ${destDisk}` };\r\n        }\r\n\r\n        const srcEntry = fileTables[srcDisk][srcPath];\r\n        const destExists = !!fileTables[destDisk][destPath];\r\n\r\n        if (destExists && !overwrite) {\r\n            throw { name: 'AlreadyExists', message: `Destination already exists: ${destFullPath}` };\r\n        }\r\n\r\n        await ensureParentFolders(destDisk, destPath);\r\n\r\n        if (srcEntry.type === types.file) {\r\n            const blob = await readFile(srcFullPath);\r\n            await writeFile(destFullPath, blob);\r\n            await rm(srcFullPath);\r\n        } else if (srcEntry.type === types.dir) {\r\n            const entries = await readdir(srcFullPath, { recursive: true });\r\n            entries.push(srcFullPath);\r\n\r\n            for (const entryPath of entries) {\r\n                const relativePath = entryPath.slice(srcFullPath.length);\r\n                const targetPath = destFullPath + relativePath;\r\n\r\n                const entry = fileTables[srcDisk][parsePath(entryPath).path];\r\n                if (entry.type === types.file) {\r\n                    const blob = await readFile(entryPath);\r\n                    await writeFile(targetPath, blob);\r\n                } else if (entry.type === types.dir) {\r\n                    await ensureParentFolders(destDisk, parsePath(targetPath).path);\r\n                    fileTables[destDisk][parsePath(targetPath).path] = {\r\n                        ...entry,\r\n                        createdTime: Date.now(),\r\n                        lastModifiedTime: Date.now()\r\n                    };\r\n                }\r\n            }\r\n\r\n            await rm(srcFullPath, { recursive: true });\r\n        } else {\r\n            throw { name: 'InvalidEntry', message: `Unknown entry type at ${srcFullPath}` };\r\n        }\r\n\r\n        updateFileTable(destDisk);\r\n        updateFileTable(srcDisk);\r\n    }\r\n\r\n    /**\r\n     * Read a directory\r\n     * @param {string} fullPath\r\n     * @param {object} [options]\r\n     * @param {boolean} [options.recursive=false] Whether to recursively include files in subdirectories\r\n     * @returns {Promise<string[]>} If it failed, reject a {@link CustomError}\r\n     */\r\n    async function readdir(fullPath, options = {}) {\r\n        const recursive = options.recursive ?? false;\r\n        const { disk, path: rawPath } = parsePath(fullPath);\r\n        let path = rawPath.endsWith('/') ? rawPath : rawPath + '/';\r\n        if (!fileTables[disk]) {\r\n            throw {\r\n                name: 'NotFound',\r\n                message: `The disk ( ${disk} ) could not be found`\r\n            };\r\n        } else if (!fileTables[disk][path]) {\r\n            throw {\r\n                name: 'NotFound',\r\n                message: `The specified directory path ( ${fullPath} ) could not be found`\r\n            };\r\n        } else if (fileTables[disk][path].type !== types.dir) {\r\n            throw {\r\n                name: 'InvalidPath',\r\n                message: `The specified path ( ${fullPath} ) is not a directory`\r\n            };\r\n        }\r\n        const entries = Object.keys(fileTables[disk])\r\n            .filter(key => {\r\n                if (!key.startsWith(path) || key === path) return false;\r\n                if (recursive) return true;\r\n                // Non-recursive mode\r\n                const subPath = key.slice(path.length);\r\n                return subPath.split('/').filter(Boolean).length === 1;\r\n            })\r\n            .map(k => `${disk}:${k}`);\r\n        return entries;\r\n    }\r\n\r\n    /**\r\n     * Read blob\r\n     * @param {string} fullPath\r\n     * @returns {Promise<Blob>} If it failed, reject a {@link CustomError}\r\n     */\r\n    async function readFile(fullPath) {\r\n        const { disk, path } = parsePath(fullPath);\r\n        if (path == '' || path.endsWith('/') || fsUtils.basename(path) == '') {\r\n            throw {\r\n                name: '',\r\n                message: `Invalid path : ${fullPath}`\r\n            };\r\n        }\r\n        if (!fileTables[disk]) {\r\n            throw {\r\n                name: '',\r\n                message: `The disk ( ${disk} ) could not be found`\r\n            };\r\n        }\r\n        if (!fileTables[disk][path]) {\r\n            throw {\r\n                name: '',\r\n                message: `File not found: ${fullPath}`\r\n            };\r\n        }\r\n        const store = await getStore('readonly', uuid)\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const request = store.get(fileTables[disk][path].id);\r\n            request.onsuccess = async (event) => {\r\n                const file = event.target.result;\r\n                if (file) {\r\n                    resolve(file.v);\r\n                    // Cache blob\r\n                    if (window.modes.dev == false) {\r\n                        blobURLCaches[fullPath] = URL.createObjectURL(file.v);\r\n                    }\r\n                    if (file.v.type && fileTables[disk][path].mimeType != file.v.type) {\r\n                        fileTables[disk][path].mimeType = file.v.type;\r\n                        updateFileTable(disk);\r\n                    }\r\n                } else {\r\n                    reject({\r\n                        name: 'NotFound',\r\n                        message: `File not found: ${fullPath}`\r\n                    });\r\n                }\r\n            }\r\n            request.onerror = async (event) => {\r\n                const err = event.target.error;\r\n                reject({\r\n                    name: err.name,\r\n                    message: err.message\r\n                });\r\n            }\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Remove file or directory\r\n     * @param {string} fullPath \r\n     * @param {object} [options]\r\n     * @param {boolean} [options.recursive=false]\r\n     * @param {boolean} [options.force=false]\r\n     * @returns {Promise} If it failed, reject a {@link CustomError}\r\n     */\r\n    async function rm(fullPath, options = {}) {\r\n        const { recursive = false, force = false } = options;\r\n        const { disk, path } = parsePath(fullPath);\r\n        if (!fileTables[disk]) {\r\n            if (force) return;\r\n            throw {\r\n                name: 'NotFound',\r\n                message: `The disk ( ${disk} ) could not be found`\r\n            };\r\n        }\r\n\r\n        const entry = fileTables[disk][path];\r\n        if (!entry) {\r\n            if (force) return;\r\n            throw {\r\n                name: 'NotFound',\r\n                message: `The specified path ( ${fullPath} ) could not be found`\r\n            };\r\n        }\r\n        if (entry.type === types.file) {\r\n            const store = await getStore('readwrite', uuid)\r\n            await new Promise((res, rej) => {\r\n                const req = store.delete(entry.id);\r\n                req.onsuccess = () => {\r\n                    // Remove cached url\r\n                    if (blobURLCaches[disk + ':' + path]) {\r\n                        delete blobURLCaches[disk + ':' + path];\r\n                    }\r\n                    delete fileTables[disk][path];\r\n                    updateFileTable(disk);\r\n                    emit('change', {\r\n                        path: fullPath\r\n                    });\r\n                    res();\r\n                };\r\n                req.onerror = () => rej({\r\n                    name: req.error.name,\r\n                    message: req.error.message\r\n                });\r\n            });\r\n            return;\r\n        } else if (entry.type === types.dir) {\r\n            const entries = await readdir(fullPath, { recursive });\r\n            if (!recursive && entries.length > 0) {\r\n                throw {\r\n                    name: 'DirectoryNotEmpty',\r\n                    message: `Directory ( ${fullPath} ) is not empty`\r\n                };\r\n            }\r\n            const pathToRemove = entries.map(e => parsePath(e).path);\r\n            pathToRemove.push(path);\r\n\r\n            await deleteBlobsInBatches(disk, pathToRemove, uuid)\r\n            for (const path of pathToRemove) {\r\n                const entry = fileTables[disk][path];\r\n                if (entry && entry.type === types.dir) {\r\n                    delete fileTables[disk][path];\r\n                }\r\n                updateFileTable(disk);\r\n            }\r\n            updateFileTable(disk);\r\n            emit('change', {\r\n                path: fullPath\r\n            })\r\n            return;\r\n        } else {\r\n            throw {\r\n                name: 'InvalidEntry',\r\n                message: `Unknown entry type at ${fullPath}`\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the status of the specified path\r\n     * @param {string} fullPath \r\n     * @returns {Object}\r\n     */\r\n    function stat(fullPath) {\r\n        const { disk, path } = parsePath(fullPath);\r\n        if (!fileTables[disk]) {\r\n            return {\r\n                isFile: () => false,\r\n                isDirectory: () => false,\r\n                length: 0,\r\n                exists: false,\r\n                type: null,\r\n                changeTime: null,\r\n                createdTime: null,\r\n                lastModifiedTime: null,\r\n                mimeType: null\r\n            }\r\n        }\r\n        const entry = fileTables[disk][path];\r\n        if (!entry) {\r\n            return {\r\n                isFile: () => false,\r\n                isDirectory: () => false,\r\n                length: 0,\r\n                exists: false,\r\n                type: null,\r\n                changeTime: null,\r\n                createdTime: null,\r\n                lastModifiedTime: null,\r\n                mimeType: null\r\n            }\r\n        }\r\n\r\n        var length = entry.length;\r\n        if (entry.type === types.dir) {\r\n            Object.keys(fileTables[disk]).filter(t => t.startsWith(path)).forEach(p => {\r\n                length += fileTables[disk][p].length;\r\n            })\r\n        }\r\n\r\n        return {\r\n            isFile: () => entry.type === types.file,\r\n            isDirectory: () => entry.type === types.dir,\r\n            length,\r\n            exists: true,\r\n            type: entry.type === types.file ? 'file' : 'directory',\r\n            changeTime: entry.changeTime,\r\n            createdTime: entry.createdTime,\r\n            lastModifiedTime: entry.lastModifiedTime,\r\n            mimeType: entry.mimeType || ''\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Write a blob to the specified path\r\n     * @param {string} fullPath\r\n     * @param {Blob} blob \r\n     * @returns {Promise} If it failed, reject a {@link CustomError}\r\n     */\r\n    async function writeFile(fullPath, blob) {\r\n        const { disk, path } = parsePath(fullPath);\r\n        if (!fileTables[disk]) throw {\r\n            name: 'NotFound',\r\n            message: `The disk ( ${disk} ) could not be found`\r\n        };\r\n        if (fsUtils.basename(path) == '' || path.endsWith('/') || path == '') throw {\r\n            name: 'InvalidPath',\r\n            message: `Invalid path : ${fullPath}`\r\n        };\r\n        if (!isBlob(blob)) throw {\r\n            name: 'TypeError',\r\n            message: `The type of the second parameter provided ( ${Object.prototype.toString.call(blob)} ) is not [object Blob]`\r\n        };\r\n        /*if (!checkParentFoldersExist(disk, path)) throw {\r\n            name: '',\r\n            message: `No such file or directory : ${fullPath}`\r\n        };*/\r\n        ensureParentFolders(disk, path);\r\n        const id = fileTables[disk][path] ? fileTables[disk][path].id : randomID(idLength);\r\n        const now = Date.now();\r\n        const store = await getStore('readwrite', uuid);\r\n        return new Promise((resolve, reject) => {\r\n            const request = store.put({\r\n                k: id,\r\n                v: blob\r\n            })\r\n            request.onsuccess = async () => {\r\n                if (!fileTables[disk][path]) {\r\n                    fileTables[disk][path] = {\r\n                        type: types.file,\r\n                        changeTime: now,\r\n                        createdTime: now,\r\n                        lastModifiedTime: now,\r\n                        length: blob.size,\r\n                        id,\r\n                        mimeType: blob.type || ''\r\n                    };\r\n                } else {\r\n                    if (fileTables[disk][path].type == types.file) {\r\n                        fileTables[disk][path].changeTime = now;\r\n                        fileTables[disk][path].lastModifiedTime = now;\r\n                        fileTables[disk][path].length = blob.size;\r\n                        fileTables[disk][path].mimeType = blob.type || '';\r\n                    }\r\n                }\r\n                updateFileTable(disk);\r\n                emit('change', {\r\n                    path: fullPath\r\n                })\r\n                // Cache blob\r\n                if (window.modes.dev == false) {\r\n                    blobURLCaches[fullPath] = URL.createObjectURL(blob);\r\n                }\r\n                resolve();\r\n            }\r\n            request.onerror = async (event) => {\r\n                const err = event.target.error;\r\n                reject({\r\n                    name: err.name,\r\n                    message: err.message\r\n                });\r\n            }\r\n        })\r\n    }\r\n\r\n    // =================== Proxy for Web Workers =================== //\r\n\r\n    /**\r\n     * Proxy\r\n     * @param {string} method \r\n     * @param {*} param \r\n     * @returns \r\n     */\r\n    async function proxy(method, param) {\r\n        const availableAPIs = { exists, mkdir, mv, on, readdir, readFile, rm, stat, writeFile };\r\n        if (Object.keys(availableAPIs).includes(method)) {\r\n            return availableAPIs[method](...param);\r\n        }\r\n    }\r\n\r\n    // =================== Convenient functions ==================== //\r\n\r\n    /**\r\n     * Download file to idbfs and returns file content\r\n     * @param {string} fullPath \r\n     * @param {string} [responseType=blob]\r\n     * @returns {(Blob|string)}\r\n     */\r\n    async function downloadFile(fullPath, responseType = 'blob') {\r\n        if (__dirname != \"\") {\r\n            fullPath = fsUtils.resolve(__dirname, fullPath);\r\n        }\r\n        if (!fullPath || typeof fullPath !== 'string' || fullPath.trim().length == 0) return;\r\n        if (debugMode == true) {\r\n            // Debugger\r\n            print(getStackTrace(), fullPath);\r\n        }\r\n        if (\r\n            navigator.onLine != true                            // Offline\r\n            || window.needsUpdate == false && window.modes.dev == false  // Installed\r\n            || fullPath.startsWith('C:/User/Desktop/')   // Desktop folder\r\n        ) {\r\n            return await readFile(fullPath);\r\n        }\r\n        const { disk, path } = parsePath(fullPath);\r\n        if (disk != 'C') throw {\r\n            name: 'InvalidPath',\r\n            message: ''\r\n        };\r\n        return fetch(path).then(response => {\r\n            if (response.ok) {\r\n                return response.blob();\r\n            } else {\r\n                print(`Failed to fetch file: ${fullPath}`);\r\n                throw new Error('Fetch failed');\r\n            }\r\n        }).then(async blob => {\r\n            writeFile(fullPath, blob);\r\n            if (responseType == 'text') {\r\n                return await blob.text();\r\n            } else {\r\n                return blob;\r\n            }\r\n        }).catch(async err => {\r\n            print(`Failed to fetch file: ${fullPath}`, err);\r\n            const blob = await readFile(fullPath);\r\n            if (responseType == 'text') {\r\n                return await blob.text();\r\n            }\r\n            return blob;\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Get the blob URL of the file\r\n     * @param {string} fullPath\r\n     * @returns {Promise<string>}\r\n     */\r\n    async function getFileURL(fullPath) {\r\n        if (__dirname != \"\") {\r\n            fullPath = fsUtils.resolve(__dirname, fullPath);\r\n        }\r\n        if (blobURLCaches[fullPath] && window.modes.dev == false) return blobURLCaches[fullPath];\r\n\r\n        const blob = await downloadFile(fullPath);\r\n        if (!blob) return '';\r\n        const blobURL = URL.createObjectURL(blob);\r\n        if (window.modes.dev == false) blobURLCaches[fullPath] = blobURL;\r\n        return blobURL;\r\n    }\r\n\r\n    /**\r\n     * Get file content\r\n     * @param {string} fullPath \r\n     * @returns {Promise<string>}\r\n     */\r\n    async function readFileAsText(fullPath) {\r\n        if (__dirname != \"\") {\r\n            fullPath = fsUtils.resolve(__dirname, fullPath);\r\n        }\r\n        if (\r\n            navigator.onLine != true                            // Offline\r\n            || window.needsUpdate == false && window.modes.dev == false  // Installed\r\n            || fullPath.startsWith('C:/User/Desktop/')       // Desktop folder\r\n        ) {\r\n            return await (await readFile(fullPath)).text();\r\n        }\r\n        const { disk, path } = parsePath(fullPath);\r\n        if (disk != 'C') throw {\r\n            name: 'InvalidPath',\r\n            message: ''\r\n        };\r\n        return fetch(path).then(response => {\r\n            if (response.ok) {\r\n                return response.blob();\r\n            } else {\r\n                print(`Failed to fetch file: ${fullPath}`);\r\n            }\r\n        }).then(async blob => {\r\n            writeFile(fullPath, blob);\r\n            return await blob.text();\r\n        }).catch(async err => {\r\n            print(`Failed to fetch file: ${fullPath}`, err);\r\n            return await (await readFile(fullPath)).text();\r\n        })\r\n    }\r\n\r\n    // ==================== Deprecated functions ==================== //\r\n\r\n    /**\r\n     * Get file extension\r\n     * @param {string} file \r\n     * @returns {string}\r\n     */\r\n    function getFileExtension(file = '') {\r\n        console.warn('%cfs.getFileExtension()%c has been deprecated.\\nPlease use %cutils.getFileExtension()%c instead', 'font-family:monospace;background:rgb(24,24,24);color:#fff;border-radius:4px;padding:4px 6px;', '', 'font-family:monospace;background:rgb(24,24,24);color:#fff;border-radius:4px;padding:4px 6px;', '');\r\n        return fsUtils.extname(file);\r\n    }\r\n\r\n    function resolvePath(path) {\r\n        if (__dirname != \"\") {\r\n            var isdir = path.endsWith('/');\r\n            path = fsUtils.resolve(__dirname, path);\r\n            if (isdir) path += '/';\r\n        }\r\n        return path;\r\n    }\r\n\r\n    return {\r\n        get disks() {\r\n            return Object.keys(fileTables);\r\n        },\r\n        quit: function () {\r\n            UUIDManager.deregister(uuid);\r\n        },\r\n        // =================== For main window =================== //\r\n        exists, mkdir, mv, on, readdir, readFile, rm, stat, writeFile,\r\n        // =================== For Web Workers =================== //\r\n        proxy,\r\n        // ================= Convenient functions ================ //\r\n        downloadFile, getFileURL, readFileAsText,\r\n        // ================= Deprecated functions ================ //\r\n        getFileExtension, resolvePath\r\n    };\r\n}\r\n\r\nwindow.IDBFS = IDBFS;\r\nwindow.fsUtils = fsUtils;\r\n\r\nObject.freeze(window.IDBFS);\r\nObject.freeze(window.fsUtils);\r\n\r\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);\n\n//# sourceURL=webpack://winbows11/./src/shared/fs.js?\n}")}},__webpack_module_cache__={},hasSymbol,webpackQueues,webpackExports,webpackError,resolveQueue;function __webpack_require__(r){var e=__webpack_module_cache__[r];if(void 0!==e)return e.exports;var n=__webpack_module_cache__[r]={id:r,exports:{}};return __webpack_modules__[r](n,n.exports,__webpack_require__),n.exports}hasSymbol="function"==typeof Symbol,webpackQueues=hasSymbol?Symbol("webpack queues"):"__webpack_queues__",webpackExports=hasSymbol?Symbol("webpack exports"):"__webpack_exports__",webpackError=hasSymbol?Symbol("webpack error"):"__webpack_error__",resolveQueue=r=>{r&&r.d<1&&(r.d=1,r.forEach((r=>r.r--)),r.forEach((r=>r.r--?r.r++:r())))},__webpack_require__.a=(r,e,n)=>{var t;n&&((t=[]).d=-1);var s,i,a,l=new Set,o=r.exports,d=new Promise(((r,e)=>{a=e,i=r}));d[webpackExports]=o,d[webpackQueues]=r=>(t&&r(t),l.forEach(r),d.catch((r=>{}))),r.exports=d,e((r=>{var e;s=(r=>r.map((r=>{if(null!==r&&"object"==typeof r){if(r[webpackQueues])return r;if(r.then){var e=[];e.d=0,r.then((r=>{n[webpackExports]=r,resolveQueue(e)}),(r=>{n[webpackError]=r,resolveQueue(e)}));var n={};return n[webpackQueues]=r=>r(e),n}}var t={};return t[webpackQueues]=r=>{},t[webpackExports]=r,t})))(r);var n=()=>s.map((r=>{if(r[webpackError])throw r[webpackError];return r[webpackExports]})),i=new Promise((r=>{(e=()=>r(n)).r=0;var i=r=>r!==t&&!l.has(r)&&(l.add(r),r&&!r.d&&(e.r++,r.push(e)));s.map((r=>r[webpackQueues](i)))}));return e.r?i:n()}),(r=>(r?a(d[webpackError]=r):i(o),resolveQueue(t)))),t&&t.d<0&&(t.d=0)},__webpack_require__.n=r=>{var e=r&&r.__esModule?()=>r.default:()=>r;return __webpack_require__.d(e,{a:e}),e},__webpack_require__.d=(r,e)=>{for(var n in e)__webpack_require__.o(e,n)&&!__webpack_require__.o(r,n)&&Object.defineProperty(r,n,{enumerable:!0,get:e[n]})},__webpack_require__.o=(r,e)=>Object.prototype.hasOwnProperty.call(r,e),__webpack_require__.r=r=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(r,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(r,"__esModule",{value:!0})},__webpack_require__.nc=void 0;var __webpack_exports__=__webpack_require__("./src/install/install.js")})();